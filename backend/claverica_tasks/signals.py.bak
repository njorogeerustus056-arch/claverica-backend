# tasks/signals.py
from django.db.models.signals import post_save, pre_save
from django.dispatch import receiver
from django.contrib.auth import get_user_model
from .models import UserTaskItem, UserRewardBalance, RewardWithdrawal
from django.db import transaction

User = get_user_model()


# -----------------------
# Track previous status for UserTask
# -----------------------
@receiver(pre_save, sender=UserTask)
def track_user_task_status(sender, instance, **kwargs):
    """Store the previous status before saving"""
    if instance.pk:
        try:
            instance._previous_status = UserTaskItem.objects.get(pk=instance.pk).status
        except UserTaskItem.DoesNotExist:
            instance._previous_status = None
    else:
        instance._previous_status = None


# -----------------------
# Update UserRewardBalance when UserTask is created
# -----------------------
@receiver(post_save, sender=UserTask)
def update_balance_on_task_create(sender, instance, created, **kwargs):
    """Update balance when a UserTask is created"""
    if created and instance.status in ['pending', 'in_progress']:
        with transaction.atomic():
            balance, _ = UserRewardBalance.objects.select_for_update().get_or_create(
                user=instance.user
            )
            balance.tasks_pending += 1
            balance.pending_balance += instance.task.reward_amount
            balance.save()


# -----------------------
# Update UserRewardBalance when UserTask status changes to completed
# -----------------------
@receiver(post_save, sender=UserTask)
def update_balance_on_task_completed(sender, instance, **kwargs):
    """Update balance when a UserTask is marked as completed"""
    # Check if status changed to 'completed'
    previous_status = getattr(instance, '_previous_status', None)
    
    if instance.status == 'completed' and previous_status != 'completed':
        with transaction.atomic():
            balance, _ = UserRewardBalance.objects.select_for_update().get_or_create(
                user=instance.user
            )
            
            if instance.reward_earned > 0:
                # Add to earned balance
                balance.add_earnings(instance.reward_earned)
                
                # Reduce pending balance if it was counted
                balance.pending_balance = max(
                    balance.pending_balance - instance.reward_earned,
                    0
                )
                balance.tasks_pending = max(balance.tasks_pending - 1, 0)
                
                balance.save()


# -----------------------
# Deduct available balance when a withdrawal is created
# -----------------------
@receiver(post_save, sender=RewardWithdrawal)
def deduct_balance_on_withdrawal(sender, instance, created, **kwargs):
    """Deduct balance when a withdrawal is created"""
    if created and instance.status == 'pending':
        with transaction.atomic():
            balance, _ = UserRewardBalance.objects.select_for_update().get_or_create(
                user=instance.user
            )
            success = balance.deduct_withdrawal(instance.amount)
            
            if not success:
                # If deduction fails, mark withdrawal as failed
                instance.status = 'failed'
                instance.processor_notes = 'Insufficient balance'
                # Don't save here to avoid recursion - let the caller handle it
            else:
                # Update withdrawal with transaction reference
                instance.transaction_id = f"WDR-{instance.id:06d}"
                # Don't save here to avoid recursion


# -----------------------
# Create UserRewardBalance when a User is created
# -----------------------
@receiver(post_save, sender=User)
def create_user_reward_balance(sender, instance, created, **kwargs):
    """Create a UserRewardBalance when a new user is created"""
    if created:
        UserRewardBalance.objects.get_or_create(user=instance)